#!/usr/bin/env python3
"""
NFC Reader Script with NDEF Parsing using PN532 Module

This script continuously scans for NFC tags using the PN532 module,
reads the raw data from each memory page, aggregates it, parses the first
NDEF message, and prints the extracted data to the console.

Ensure that the PN532 is correctly connected to the Raspberry Pi via SPI.
"""

import RPi.GPIO as GPIO
import time
import sys
import signal
import logging

from pn532 import PN532_SPI  # Importing the PN532_SPI class from the pn532 library

# Configure logging to display only INFO level messages
logging.basicConfig(
    filename='nfc_reader_ndef.log',  # Log file name
    filemode='a',                     # Append mode
    format='%(asctime)s %(levelname)s:%(message)s',
    level=logging.INFO                 # Set logging level to INFO
)

# Configuration Constants
SPI_CS_PIN = 4        # Chip Select pin for SPI (GPIO pin 4)
PN532_RESET_PIN = 20  # Reset pin for PN532 (GPIO pin 20)

def signal_handler(sig, frame):
    """Handle exit signals to ensure GPIO cleanup."""
    print("\nExiting program.")
    logging.info("Exiting program.")
    GPIO.cleanup()
    sys.exit(0)

def initialize_pn532():
    """Initialize the PN532 module and return the PN532 object."""
    try:
        pn532 = PN532_SPI(cs=SPI_CS_PIN, reset=PN532_RESET_PIN, debug=False)
        ic, ver, rev, support = pn532.get_firmware_version()
        print(f'Found PN532 with firmware version: {ver}.{rev}')
        logging.info(f'Found PN532 with firmware version: {ver}.{rev}')
        pn532.SAM_configuration()
        print('PN532 SAM configuration completed.')
        logging.info('PN532 SAM configuration completed.')
        return pn532
    except Exception as e:
        print(f"Failed to initialize PN532: {e}")
        logging.error(f"Failed to initialize PN532: {e}")
        GPIO.cleanup()
        sys.exit(1)

def extract_first_ndef(hex_list):
    """
    Extracts the first NDEF Text Record from a list of hexadecimal bytes.

    Parameters:
    hex_list (list of int): List of hexadecimal byte values (e.g., [0x04, 0x56, 0x97, ...])

    Returns:
    str or None: The text content of the first NDEF Text Record found, or None if not found.
    """
    # Convert the list of integers to a bytes object for easier manipulation
    data = bytes(hex_list)
    length = len(data)
    index = 0

    while index < length:
        # Read the header byte
        header = data[index]
        MB = (header & 0x80) >> 7  # Message Begin
        ME = (header & 0x40) >> 6  # Message End
        CF = (header & 0x20) >> 5  # Chunk Flag
        SR = (header & 0x10) >> 4  # Short Record
        IL = (header & 0x08) >> 3  # ID Length
        TNF = header & 0x07         # Type Name Format

        # Move to the next byte
        index += 1

        if index >= length:
            break

        # Type Length
        type_length = data[index]
        index += 1

        if SR:
            # Short Record: Payload Length is 1 byte
            payload_length = data[index]
            index += 1
        else:
            # Normal Record: Payload Length is 4 bytes
            if index + 4 > length:
                break
            payload_length = int.from_bytes(data[index:index+4], byteorder='big')
            index += 4

        # ID Length (if IL flag is set)
        if IL:
            if index >= length:
                break
            id_length = data[index]
            index += 1
        else:
            id_length = 0

        # Type
        if index + type_length > length:
            break
        type_field = data[index:index+type_length]
        index += type_length

        # ID (if IL flag is set)
        if IL:
            if index + id_length > length:
                break
            id_field = data[index:index+id_length]
            index += id_length
        else:
            id_field = None

        # Payload
        if index + payload_length > length:
            break
        payload = data[index:index+payload_length]
        index += payload_length

        # Check if this is a Text Record (Type 'T') and TNF is Well-Known (0x01)
        if type_field == b'T' and TNF == 0x01:
            if len(payload) < 1:
                return None
            status_byte = payload[0]
            encoding = 'utf-8' if (status_byte & 0x80) == 0 else 'utf-16'
            lang_length = status_byte & 0x3F  # Lower 6 bits
            if len(payload) < 1 + lang_length:
                return None
            language_code = payload[1:1+lang_length].decode('ascii', errors='ignore')
            text = payload[1+lang_length:].decode(encoding, errors='ignore')
            return text

        # If ME (Message End) flag is set, stop searching
        if ME:
            break

    # If no NDEF Text Record is found
    return None

def read_raw_memory(pn532):
    """
    Read the raw memory data from the NFC tag, extract NDEF message, and print it.

    Args:
        pn532: Initialized PN532 object.
    """
    try:
        # NTAG213 has 45 pages (0 to 44), each page is 4 bytes
        total_pages = 45
        all_data = []

        for page in range(total_pages):
            block_data = pn532.ntag2xx_read_block(page)
            if block_data is None:
                logging.warning(f"Block {page} returned None.")
                continue
            # Append each byte to the all_data list
            all_data.extend(block_data)

        if not all_data:
            print("No data read from the NFC tag.")
            logging.info("No data read from the NFC tag.")
            return

        # Extract NDEF message
        ndef_message = extract_first_ndef(all_data)

        if ndef_message is not None:
            print(f"Extracted NDEF Message: '{ndef_message}'")
            logging.info(f"Extracted NDEF Message: '{ndef_message}'")
        else:
            print("No NDEF Text Record found in the tag.")
            logging.info("No NDEF Text Record found in the tag.")

    except Exception as e:
        print(f"Error reading raw memory: {e}")
        logging.error(f"Error reading raw memory: {e}")

def main():
    """Main function to run the NFC reader."""
    # Handle graceful exit
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    pn532 = initialize_pn532()

    print('Waiting for NFC tag...')
    logging.info('Waiting for NFC tag...')

    while True:
        try:
            # Wait for a card. Timeout set to 1 second.
            uid = pn532.read_passive_target(timeout=1.0)
            if uid is not None:
                uid_hex = ':'.join(f'{byte:02X}' for byte in uid)
                print(f'\nFound NFC tag with UID: {uid_hex}')
                logging.info(f"Found NFC tag with UID: {uid_hex}")

                # Read and display NDEF data
                read_raw_memory(pn532)

                print('\nWaiting for the next NFC tag...')
                logging.info("Waiting for the next NFC tag...")

                # Optional: Wait until the tag is removed before continuing
                while pn532.read_passive_target(timeout=1.0) is not None:
                    time.sleep(0.1)
            else:
                # No tag found; continue scanning
                time.sleep(0.1)
        except Exception as e:
            print(f"\nUnexpected error: {e}")
            logging.error(f"Unexpected error: {e}")
            time.sleep(1)

if __name__ == '__main__':
    main()
