#!/usr/bin/env python3
"""
Enhanced NFC Reader Script using PN532 Module

This script continuously scans for NFC tags using the PN532 module,
efficiently scans relevant pages to locate the NDEF message,
parses various types of NDEF records, converts them into readable strings,
and prints them to the console. It waits for the next NFC tag after processing one.
"""

import RPi.GPIO as GPIO
import time
import sys
import signal
import logging
from typing import Tuple, Optional

import pn532.pn532 as nfc
from pn532 import PN532_SPI

# Configure logging
logging.basicConfig(
    filename='nfc_reader.log',
    filemode='a',
    format='%(asctime)s %(levelname)s:%(message)s',
    level=logging.DEBUG
)

# Configuration Constants
SPI_CS_PIN = 4        # Chip Select pin for SPI
PN532_RESET_PIN = 20  # Reset pin for PN532
DEBUG = False         # Set to True to enable debug output

def signal_handler(sig, frame):
    """Handle exit signals to ensure GPIO cleanup."""
    print("\nExiting program.")
    logging.info("Exiting program.")
    GPIO.cleanup()
    sys.exit(0)

def initialize_pn532() -> Optional[PN532_SPI]:
    """Initialize the PN532 module and return the PN532 object."""
    try:
        pn532 = PN532_SPI(cs=SPI_CS_PIN, reset=PN532_RESET_PIN, debug=DEBUG)
        ic, ver, rev, support = pn532.get_firmware_version()
        print(f'Found PN532 with firmware version: {ver}.{rev}')
        logging.info(f'Found PN532 with firmware version: {ver}.{rev}')
        pn532.SAM_configuration()
        print('PN532 SAM configuration completed.')
        logging.info('PN532 SAM configuration completed.')
        return pn532
    except Exception as e:
        print(f"Failed to initialize PN532: {e}")
        logging.error(f"Failed to initialize PN532: {e}")
        GPIO.cleanup()
        return None

def parse_ndef_record(ndef_data: bytearray) -> Optional[dict]:
    """
    Parse an NDEF record.

    Args:
        ndef_data: bytearray containing the NDEF record.

    Returns:
        Dictionary containing parsed record information or None if parsing fails.
    """
    try:
        if len(ndef_data) < 3:
            logging.warning("NDEF data too short.")
            return None

        header = ndef_data[0]
        tnf = header & 0x07
        sr = (header & 0x10) >> 4
        il = (header & 0x08) >> 3

        type_length = ndef_data[1]
        payload_length = ndef_data[2] if sr else int.from_bytes(ndef_data[2:6], 'big')
        id_length = ndef_data[3 if sr else 6] if il else 0

        offset = 3 if sr else 6
        offset += 1 if il else 0

        type_field = ndef_data[offset:offset+type_length]
        offset += type_length

        id_field = ndef_data[offset:offset+id_length] if il else None
        offset += id_length if il else 0

        payload = ndef_data[offset:offset+payload_length]

        record = {
            'tnf': tnf,
            'type': type_field,
            'id': id_field,
            'payload': payload
        }

        if type_field == b'T':
            record['decoded'] = parse_text_payload(payload)
        elif type_field == b'U':
            record['decoded'] = parse_uri_payload(payload)
        else:
            record['decoded'] = payload.hex()

        return record
    except Exception as e:
        logging.error(f"Error parsing NDEF record: {e}")
        return None

def parse_text_payload(payload: bytearray) -> str:
    """Parse a Text record payload."""
    try:
        status_byte = payload[0]
        encoding = 'utf-16' if status_byte & 0x80 else 'utf-8'
        lang_length = status_byte & 0x3F
        text = payload[1 + lang_length:].decode(encoding)
        return text
    except Exception as e:
        logging.error(f"Error parsing text payload: {e}")
        return "Error: Unable to parse text"

def parse_uri_payload(payload: bytearray) -> str:
    """Parse a URI record payload."""
    try:
        prefix_code = payload[0]
        URI_PREFIX_MAP = {
            0x00: "",
            0x01: "http://www.",
            0x02: "https://www.",
            0x03: "http://",
            0x04: "https://",
            0x05: "tel:",
            0x06: "mailto:",
            # Add more prefixes as needed
        }
        prefix = URI_PREFIX_MAP.get(prefix_code, "")
        uri = prefix + payload[1:].decode('utf-8')
        return uri
    except Exception as e:
        logging.error(f"Error parsing URI payload: {e}")
        return "Error: Unable to parse URI"

def scan_for_ndef(pn532: PN532_SPI) -> Tuple[Optional[int], Optional[bytearray]]:
    """
    Efficiently scan pages to locate the NDEF message.

    Args:
        pn532: Initialized PN532 object.

    Returns:
        Tuple (start_page, ndef_data) or (None, None) if not found.
    """
    try:
        total_pages = 45  # NTAG213 has 45 pages (0-44)
        ndef_data = bytearray()
        found_header = False
        page_size = 4  # bytes per page

        for page in range(4, total_pages, 4):  # Read 4 pages at a time
            block_data = pn532.ntag2xx_read_block(page)
            if block_data is None:
                logging.warning(f"Block {page} returned None.")
                continue
            
            for i in range(0, 16, page_size):
                if not found_header and block_data[i] == 0x03:  # NDEF Message TLV tag
                    found_header = True
                    ndef_length = block_data[i+1]
                    ndef_data.extend(block_data[i+2:])
                    break
                elif found_header:
                    ndef_data.extend(block_data[i:i+page_size])

            if found_header and len(ndef_data) >= ndef_length:
                return page, ndef_data[:ndef_length]

        if not found_header:
            logging.warning("NDEF Message TLV not found in any page.")
        return None, None
    except Exception as e:
        logging.error(f"Error during NDEF scanning: {e}")
        return None, None

def read_ndef_message(pn532: PN532_SPI, uid: bytes) -> Optional[list]:
    """
    Read NDEF message from the NFC tag.

    Args:
        pn532: Initialized PN532 object.
        uid: UID of the detected NFC tag.

    Returns:
        List of parsed NDEF records or None if not found.
    """
    try:
        start_page, ndef_data = scan_for_ndef(pn532)
        if ndef_data is None:
            logging.info("No readable NDEF message found.")
            return None

        records = []
        offset = 0
        while offset < len(ndef_data):
            record = parse_ndef_record(ndef_data[offset:])
            if record:
                records.append(record)
                offset += len(record['payload']) + 3  # Header (1) + Type Length (1) + Payload Length (1)
                if record['tnf'] & 0x40:  # ME (Message End) flag
                    break
            else:
                break

        return records
    except Exception as e:
        logging.error(f"Error reading NDEF message: {e}")
        return None

def main():
    """Main function to run the NFC reader."""
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    pn532 = initialize_pn532()
    if not pn532:
        print("Failed to initialize PN532. Exiting.")
        sys.exit(1)

    print('Waiting for RFID/NFC card to read from...')

    while True:
        try:
            uid = pn532.read_passive_target(timeout=1.0)
            print('.', end="", flush=True)

            if uid is not None:
                print('\nFound card with UID:', [hex(i) for i in uid])
                logging.info(f"Found card with UID: {[hex(i) for i in uid]}")

                ndef_records = read_ndef_message(pn532, uid)
                if ndef_records:
                    print('NDEF Records:')
                    for idx, record in enumerate(ndef_records, 1):
                        print(f"Record {idx}:")
                        print(f"  Type: {record['type'].decode('utf-8')}")
                        print(f"  Decoded: {record['decoded']}")
                else:
                    print('No readable NDEF message found.')
                    logging.info("No readable NDEF message found.")

                print('Waiting for the next card...\n')

                while pn532.read_passive_target(timeout=1.0) is not None:
                    time.sleep(0.1)

        except Exception as e:
            print(f"\nError: {e}")
            logging.error(f"Unexpected error: {e}")

        time.sleep(0.1)

if __name__ == '__main__':
    main()